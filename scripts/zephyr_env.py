import os
import argparse
import re
from colorama import init, Fore

init(autoreset=True)

def validate_cmake_version(version):
    if not re.match(r"^\d+\.\d+(\.\d+)?$", version):
        raise ValueError("Invalid CMake version format. Use something like '3.20.0'")
    return version

def write_file(path, content, overwrite=False):
    if os.path.exists(path) and not overwrite:
        print(Fore.YELLOW + f"Skipped existing: {path}")
        return
    with open(path, "w") as f:
        f.write(content)
    print(Fore.GREEN + f"Generated: {path}")

def generate_project(
    project_name,
    cmake_version,
    language,
    output_folder,
    board,
    overlay,
    overwrite=False
):
    cmake_version = cmake_version or "3.20.0"
    language = language or "C"
    board = board or "qemu_riscv64"
    overlay = overlay or "app"

    try:
        validate_cmake_version(cmake_version)
    except ValueError as e:
        print(Fore.RED + str(e))
        return

    os.makedirs(output_folder, exist_ok=True)

    # CMakeLists.txt
    cmake_content = f"""# Minimum CMake version required
cmake_minimum_required(VERSION {cmake_version})

# Include Zephyr
find_package(Zephyr REQUIRED HINTS $ENV{{ZEPHYR_BASE}})

# Define project
project(
  {project_name}
  VERSION 1.0
  DESCRIPTION "Zephyr project generated by script"
  LANGUAGES {language}
)

# Add main source file
target_sources(app PRIVATE src/main.c)

"""
    write_file(os.path.join(output_folder, "CMakeLists.txt"), cmake_content, overwrite)
    # prj.conf
    prj_conf_content = f"""# Emul
CONFIG_EMUL=y

# I2C
CONFIG_I2C=y
CONFIG_I2C_EMUL=y

# Sensor drivers
CONFIG_SENSOR=y
#CONFIG_BH1750=y
#CONFIG_SHT3XD=y

#GPIO
CONFIG_GPIO=y
CONFIG_GPIO_EMUL=y

# Random
CONFIG_STACK_POINTER_RANDOM=0
CONFIG_TEST_RANDOM_GENERATOR=y
CONFIG_TIMER_RANDOM_GENERATOR=y
CONFIG_TEST_CSPRNG_GENERATOR=y

# Print Float
CONFIG_CBPRINTF_FP_SUPPORT=y

# General logging
CONFIG_LOG=y
#CONFIG_LOG_DEFAULT_LEVEL=4
"""
    write_file(os.path.join(output_folder, "prj.conf"), prj_conf_content, overwrite)


    # Overlay files
    boards_dir = os.path.join(output_folder, "boards")
    os.makedirs(boards_dir, exist_ok=True)

    native_sim_overlay_content = """&i2c0 {
    status = "okay";
    clock-frequency = <I2C_BITRATE_STANDARD>; /* 100kHz */
};

&gpio0 {
    status = "okay";
};

&led0 {
    status = "okay";
};
"""
    write_file(os.path.join(output_folder, "boards/native_sim.overlay"), native_sim_overlay_content, overwrite)

    esp32s3_devkitc_content = """&i2c0 {
    status = "okay";
    clock-frequency = <I2C_BITRATE_STANDARD>; /* 100kHz */
};

/ {
	  aliases {
        led0 = &led0;
	  };


    leds {
        compatible = "gpio-leds";
        led0: led_0 {
            gpios = <&fakegpio 0 GPIO_ACTIVE_HIGH>;
            label = "FAKE_LED_0";
        };
    };

    fakegpio: gpio@0 {
        compatible = "zephyr,gpio-emul";
        gpio-controller;
        #gpio-cells = <2>;
        reg = <0 0x1000>;  /* Corrected reg property format */
        #address-cells = <1>;
        #size-cells = <1>;
        ngpios = <32>;
        status = "okay";
    };
};
"""
    write_file(os.path.join(output_folder, "boards/esp32s3_devkitc.overlay"), esp32s3_devkitc_content, overwrite)

    util_dir = os.path.join(output_folder, "utils")
    os.makedirs(util_dir, exist_ok=True)
    qemu_content = """\
dd if=/dev/zero of=build/zephyr/zephyr_4mb.bin bs=1M count=4
dd if=build/zephyr/zephyr.bin of=build/zephyr/zephyr_4mb.bin conv=notrunc
qemu-system-xtensa -nographic -machine esp32s3 -drive file=build/zephyr/zephyr_4mb.bin,if=mtd,format=raw
"""
    write_file(os.path.join(output_folder, "utils/qemu_esp32.sh"), qemu_content, overwrite)

    # Makefile
    makefile_content = f"""\
DRIVER  ?= sensirion_sht3xd_emul
ITF     ?= i2c
ADD     ?= 44

BOARD   ?= {board}
OVERLAY ?= {overlay}

ORANGE  :=\\033[38;5;214m
RESET   :=\\033[0m

all: config build run

add-driver:
\tpython3 ../scripts/zephyr_driver_emul.py -m $(DRIVER) -i $(ITF) -a $(ADD) -o ../modules

config:
\tcmake -S . -B build -DBOARD=$(BOARD) -DDTC_OVERLAY_FILE=boards/$(OVERLAY).overlay

menuconfig: config
\tcmake --build build --target menuconfig

build:
\tcmake --build build

run:
\tcmake --build build --target run

clean:
\trm -rf build

west-build:
\twest build -p always -b $(BOARD) -- -DDTC_OVERLAY_FILE=boards/$(OVERLAY).overlay

west-run:
\twest build -t run

help:
\t@echo "$(ORANGE)"
\t@echo "Makefile targets:"
\t@echo ""
\t@echo "all         Run config, build, and run"
\t@echo "config      Configure the build with CMake"
\t@echo "menuconfig  Run menuconfig (interactive config)"
\t@echo "build       Build using CMake"
\t@echo "run         Run using CMake"
\t@echo "west-build  Build using west (recommended)"
\t@echo "west-run    Run using west (if supported)"
\t@echo "clean       Remove build directory"
\t@echo "help        Show this help message"
\t@echo "$(RESET)"
"""
    write_file(os.path.join(output_folder, "Makefile"), makefile_content, overwrite)

    # main.c
    src_dir = os.path.join(output_folder, "src")
    os.makedirs(src_dir, exist_ok=True)
    main_c_content = """\
// Kernel and driver includes

#include <zephyr/kernel.h>
#include <zephyr/device.h>
#include <zephyr/devicetree.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/logging/log.h>

LOG_MODULE_REGISTER(main, LOG_LEVEL_INF);

// Constants and thread configuration

#define STACK_SIZE 1024
#define LED_PRIORITY 5
#define LED_BLINK_INTERVAL_MS 500

// LED GPIO configuration

#define LED0_NODE DT_NODELABEL(led0)
static const struct gpio_dt_spec led = GPIO_DT_SPEC_GET(LED0_NODE, gpios);

// Thread stack and control block

K_THREAD_STACK_DEFINE(led_stack, STACK_SIZE);
static struct k_thread led_thread_data;

// LED Thread

void led_thread(void *arg1, void *arg2, void *arg3)
{
    bool state = false;

    while (1) {
        state = !state;
        gpio_pin_set_dt(&led, state);
        LOG_INF("LED: %s", state ? "ON" : "OFF");
        k_msleep(LED_BLINK_INTERVAL_MS);
    }
}

// Main Function

int main(void)
{
    LOG_INF("Booting LED Blink Application...");

    if (!device_is_ready(led.port)) {
        LOG_ERR("LED device not ready");
        return 0;
    }

    if (gpio_pin_configure_dt(&led, GPIO_OUTPUT_ACTIVE) < 0) {
        LOG_ERR("Failed to configure LED GPIO");
        return 0;
    }

    LOG_INF("LED ready. Launching thread...");

    k_thread_create(&led_thread_data, led_stack, STACK_SIZE,
                    led_thread, NULL, NULL, NULL,
                    LED_PRIORITY, 0, K_NO_WAIT);

    return 0;
}
"""

    write_file(os.path.join(src_dir, "main.c"), main_c_content, overwrite)

def main():
    parser = argparse.ArgumentParser(description="Generate a boilerplate Zephyr project structure.")
    parser.add_argument("-p", "--project_name", required=True, help="Project name")
    parser.add_argument("-v", "--c_make_version", default=None, help="CMake minimum version (default: 3.20.0)")
    parser.add_argument("-l", "--languages", default="C", help="Languages used in project (default: C)")
    parser.add_argument("-o", "--output_folder", default=".", help="Output folder (default: current directory)")
    parser.add_argument("-b", "--board", default="qemu_riscv64", help="Target board (default: qemu_riscv64)")
    parser.add_argument("-y", "--overlay", default="app", help="Overlay file name (default: app)")
    parser.add_argument("--overwrite", action="store_true", help="Overwrite existing files")

    args = parser.parse_args()

    generate_project(
        project_name=args.project_name,
        cmake_version=args.c_make_version,
        language=args.languages,
        output_folder=args.output_folder,
        board=args.board,
        overlay=args.overlay,
        overwrite=args.overwrite,
    )

if __name__ == "__main__":
    main()

